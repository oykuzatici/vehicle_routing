# -*- coding: utf-8 -*-
"""CVRP1_gurobi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oU16vroBezcQlDd9S6TBJEMoB4qhQ7Kf
"""

import gurobipy as gp
from gurobipy import GRB

def solve_cvrp(n, K, C, cost, demand):
    """
    Capacitated Vehicle Routing Problem (CVRP) solver using Gurobi and MTZ constraints.

    Parameters:
        n (int): Number of nodes (including depot)
        K (int): Number of vehicles
        C (int): Vehicle capacity
        cost (list of lists): Cost matrix (n x n)
        demand (list): Demand of each node (length n, depot demand = 0)

    Returns:
        obj (float): Optimal cost
        routes (list of tuples): Selected edges (i, j)
    """

    nodes = range(n)
    customers = range(1, n)

    # ----------------------------
    # MODEL
    # ----------------------------
    m = gp.Model("CVRP")

    # Karar değişkenleri
    x = m.addVars(nodes, nodes, vtype=GRB.BINARY, name="x")
    u = m.addVars(customers, vtype=GRB.CONTINUOUS, name="u")

    # Amaç fonksiyonu
    m.setObjective(gp.quicksum(cost[i][j]*x[i,j] for i in nodes for j in nodes if i!=j), GRB.MINIMIZE)

    # Her müşteri bir kez girilir ve çıkılır
    for i in customers:
        m.addConstr(gp.quicksum(x[i,j] for j in nodes if j!=i) == 1)
        m.addConstr(gp.quicksum(x[j,i] for j in nodes if j!=i) == 1)

    # Depo giriş-çıkış = K
    m.addConstr(gp.quicksum(x[0,j] for j in customers) == K)
    m.addConstr(gp.quicksum(x[j,0] for j in customers) == K)

    # MTZ kapasite kısıtları
    for i in customers:
        m.addConstr(u[i] >= demand[i])
        m.addConstr(u[i] <= C)

    for i in customers:
        for j in customers:
            if i != j:
                m.addConstr(u[i] - u[j] + C*x[i,j] <= C - demand[j])

    # Araç aynı düğüme gitmesin
    for i in nodes:
        m.addConstr(x[i,i] == 0)

    # ----------------------------
    # ÇÖZ
    # ----------------------------
    m.optimize()

    routes = []
    if m.status == GRB.OPTIMAL:
        obj = m.objVal
        for i in nodes:
            for j in nodes:
                if i != j and x[i,j].X > 0.5:
                    routes.append((i, j))
        return obj, routes
    else:
        return None, []