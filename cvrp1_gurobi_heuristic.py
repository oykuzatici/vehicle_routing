# -*- coding: utf-8 -*-
"""cvrp1_gurobi_heuristic.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F2GPIdqWAuh0qPTm1aDbFpEDI7yemHv0
"""

# -*- coding: utf-8 -*-
from gurobipy import Model, GRB, quicksum, tuplelist
import math

# -------------------------------------------------
# SABİT VERİ (E-n13-k4) – TSPLIB’den gömülü alındı
# -------------------------------------------------
n = 13
depot = 0
K = 4
C = 6000

# TSPLIB E-n13-k4 DEMAND_SECTION (1-based -> 0-based çevrildi)
demand0 = [0, 1200, 1700, 1500, 1400, 1700, 1400, 1200, 1900, 1800, 1600, 1700, 1100]

# TSPLIB EDGE_WEIGHT_SECTION (LOWER_ROW) düz liste (78 sayı)
numbers = [
     9, 14, 21, 23, 22, 25, 32, 36, 38, 42, 50, 52,
     5, 12, 22, 21, 24, 31, 35, 37, 41, 49, 51,
     7, 17, 16, 23, 26, 30, 36, 36, 44, 46,
     10, 21, 30, 27, 37, 43, 31, 37, 39,
     19, 28, 25, 35, 41, 29, 31,
     29,  9, 10, 16, 22, 20, 28,
     30,  7, 11, 13, 17, 25,
     27, 10, 16, 10, 18,
     20,  6,  6, 14,
     16, 12, 12, 20,
      8, 10, 10
]

# LOWER_ROW -> simetrik maliyet matrisi
def build_cost_from_lower_row(numbers, n):
    cost = [[0]*n for _ in range(n)]
    idx = 0
    for i in range(2, n+1):
        for j in range(1, i):
            cij = numbers[idx]
            idx += 1
            cost[i-1][j-1] = cij
            cost[j-1][i-1] = cij
    return cost

cost = build_cost_from_lower_row(numbers, n)

# -------------------------------------------------
# CVRP MODELİ: Tüm formüller (Gurobi)
# -------------------------------------------------
def solve_cvrp_all_formulas(cost, demand, C, K, depot, title=""):
    n = len(demand)
    nodes = range(n)
    customers = [i for i in nodes if i != depot]
    A = tuplelist((i, j) for i in nodes for j in nodes if i != j)

    def r_of(S):
        return math.ceil(sum(demand[i] for i in S) / C)

    m = Model(f"CVRP_{title}")
    m.Params.LazyConstraints = 1

    x = m.addVars(A, vtype=GRB.BINARY, name="x")
    u = m.addVars(customers, lb={i: demand[i] for i in customers}, ub=C, name="u")
    m.setObjective(quicksum(cost[i][j] * x[i, j] for i, j in A), GRB.MINIMIZE)

    # Derece ve depot kısıtları
    for j in customers:
        m.addConstr(quicksum(x[i, j] for i in nodes if i != j) == 1, name=f"in_{j}")
    for i in customers:
        m.addConstr(quicksum(x[i, j] for j in nodes if j != i) == 1, name=f"out_{i}")
    m.addConstr(quicksum(x[depot, j] for j in customers) == K, name="depot_out")
    m.addConstr(quicksum(x[i, depot] for i in customers) == K, name="depot_in")

    # MTZ kısıtları
    for i in customers:
        for j in customers:
            if i != j:
                m.addConstr(u[i] - u[j] + C * x[i, j] <= C - demand[j], name=f"mtz_{i}_{j}")

    # Lazy callback
    def cb(model, where):
        if where == GRB.Callback.MIPSOL:
            vals = model.cbGetSolution(x)
            adj = {i: set() for i in nodes}
            for (a, b) in A:
                if vals[a, b] > 1e-6:
                    adj[a].add(b)
                    adj[b].add(a)
            visited = set()
            def dfs(s):
                stack = [s]
                comp = {s}
                visited.add(s)
                while stack:
                    v = stack.pop()
                    for w in adj[v]:
                        if w not in visited:
                            visited.add(w)
                            comp.add(w)
                            stack.append(w)
                return comp
            for i in nodes:
                if i not in visited:
                    Sfull = dfs(i)
                    if depot in Sfull: continue
                    S = Sfull.intersection(customers)
                    if not S: continue
                    rS = r_of(S)
                    lhs_out_val = sum(vals[i, j] for i in S for j in nodes if j not in S)
                    if lhs_out_val < rS - 1e-6:
                        model.cbLazy(quicksum(x[i, j] for i in S for j in nodes if j not in S) >= rS)
                    lhs_in_val = sum(vals[i, j] for i in S for j in S if i != j)
                    rhs_in = len(S) - rS
                    if lhs_in_val > rhs_in + 1e-6:
                        model.cbLazy(quicksum(x[i, j] for i in S for j in S if i != j) <= rhs_in)

    m.optimize(cb)

    # ---- ÇIKTI ----
    if m.status == GRB.OPTIMAL:
        succ = {i: None for i in nodes}
        for (i, j) in A:
            if x[i, j].X > 0.5:
                succ[i] = j
        routes, used = [], set()
        starts = [j for j in customers if x[depot, j].X > 0.5]
        for s in starts:
            r = [depot, s]
            cur = s
            while True:
                nxt = succ[cur]
                if nxt is None: break
                r.append(nxt)
                cur = nxt
                if cur == depot: break
            t = tuple(r)
            if t not in used:
                used.add(t)
                routes.append(r)
        tot = 0
        for rid, r in enumerate(routes, 1):
            load = sum(demand[i] for i in r if i != depot)
            dist = sum(cost[r[k]][r[k+1]] for k in range(len(r)-1))
            tot += dist
            print(f"Route {rid}: {r} | load={load} | dist={dist}")
        print(f"Total cost = {tot}")
    else:
        print("No optimal solution found.")

    return m

# -----------------------------
# Nearest Neighbor Heuristic
# -----------------------------
def solve_vrp_nearest_neighbor(demand=None):
    if demand is None:
        demand = demand0
    n = len(demand)
    unvisited = set(range(1, n))
    routes = []
    depot_local = depot
    C_local = C

    while unvisited:
        route = [depot_local]
        cur = depot_local
        load = 0

        while unvisited:
            feasible = [i for i in unvisited if load + demand[i] <= C_local]
            if not feasible:
                break
            next_cust = min(feasible, key=lambda i: cost[cur][i])
            route.append(next_cust)
            load += demand[next_cust]
            unvisited.remove(next_cust)
            cur = next_cust

        route.append(depot_local)
        routes.append(route)

    # Çıktı
    tot_dist = 0
    for rid, r in enumerate(routes, 1):
        dist = sum(cost[r[k]][r[k+1]] for k in range(len(r)-1))
        load = sum(demand[i] for i in r if i != depot_local)
        tot_dist += dist
        print(f"Route {rid}: {r} | load={load} | dist={dist}")
    print(f"Total distance (heuristic) = {tot_dist}")
    return routes